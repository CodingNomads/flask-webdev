
Email verification
===========

Flask-Mail uses SMTP for email sending/delivery. There's different configuration keys you can use including `localhost` listed here: [list]

Sending mail from the shell: import Message, then compose message, a body, and html body then you can send within app_context()

let's make a new file email.py in the top app directory to define a function to send the email

Let's have the app email us when a new user signs up. (explain why current_app goes in `home()` view func) (also warning could get annoying so don't pick a good email)

actually no that won't go in the home form, but the register form me things. I think we're gonna remove the form on home() because it's not useful anymore

To enable SMTP connections in GMail, you'll wanna go to your Google Security Settings. as of this writing it's at: https://myaccount.google.com/security . Then, turn ON "less secure app access." Don't worry too much about the "less secure" part as Google just wants you to use OAuth2 or something. (This is fine though, right? Probably want to offer some alternatives to python's `smtplib`)

You'll also need to enable two factor authentication, then create an app password. Kinda confusing but once you get that, you'll be all set to send emails from your SECONDARY account

send_email() in email.py, along with importing `mail` from app and current_app.

Verification
-------------

Some applications like to verify that their users have valid information. The most common requirements apps ask of users is to verify their email. We'll have our app do the same so we can show you how it's done. For each new user, we'll mark the account as unconfirmed until a link in the email is clicked.

A confirmation link might be as simple as www.website.com/auth/confirm/id where id is the users id in the database. Once the link is clicked in email, the view function that handles that URL will know what the userid is and can then mark that user as confirmed. But that's not a secure implementation because anyone can just take the link in the email and change the id to anything. That's not secure, but we can make it secure very easily. Confirmation tokens can help us do that, and we'll use itsdangerous package.

A confirmation token will replace the id with something a lot more cryptic and undecypherable to a person but that only our app can generate and understand. We [didn't yet] discuss earlier that user sessions are actually protected by signed cookies. These cookies contain a signature generated by itsdangerous.

Let's demonstrate the package's ability to generate one of these

```
>>> from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
>>> s = Serializer(app.config['SECRET_KEY'], expires_in=3600)
>>> token = s.dumps({ 'icecream': 'wood' })
>>> token
b'eyJhbGciOiJIUzUxMiIsImlhdCI6MTU4MzcwOTc4NiwiZXhwIjoxNTgzNzEzMzg2fQ.eyJpY2VjcmVhbSI6Indvb2QifQ.ffG5SQcwTXFON0RA0VUk_HgiS2VCmyf0niH2VHdGjbra7p83hVtr0fmTCpmhLbqI1q7Vtq3KGXiqZnci28jE8Q'
>>> data = s.loads(token)
>>> data
{'icecream': 'wood'}
```

`dumps` generates a crypto signature for the data given. Data is serialized and the signature as a neat little token string. `expires_in` is in seconds

`loads()` method takes token, outputs original data if the exp time and signature are both valid

Let's add a confirmed column to our User model. `generate_confirmation_token()` takes an expiration in seconds and returns the generated token. `confirm()` verifies the token, if valid it will set the `confirmed` attribute to True

SQLAlchemy OperationalError from config not creating testing database (not filled in) (MAYBE NOT). Adding Environ gets to config for database names

learned that conftest doesn't work right inside classes

We use `_external` in the url_for function to indicate that we want fully qualified url, meaning the https:// or http://, hostname and port

when we make before_app_request: if the user's logged in and is not in the auth blueprint, the app will catch this in the if statement we made, then will show the "unconfirmed" page. They have to have an unconfirmed account ofc

We can send email asynchronously so we don't have to wait for the server to send the email. Basically what happens is we start a new thread to process sending the email so our app can focus on doing web things, like responding to the client. Cool huh?

    Miguels async email example didn't work. THIS saved my butt. We get the app object itself https://www.reddit.com/r/flask/comments/5jrrsu/af_appapp_context_in_thread_throws_working/