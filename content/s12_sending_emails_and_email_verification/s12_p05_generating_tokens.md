With your email support established, now it's time to generate tokens for confirming your users. This is a common practice among web apps, as it prevents spam accounts from piling up. It also makes sure your users have access to the emails they provide for validation. The tokens you'll create specific for your app will be sent to users, who will then click the links that embed them, and their accounts will be confirmed.

### Account Confirmation with Tokens

There's the wrong way to generate **tokens**, and then there's the right way. These unique tokens are generated by the app, for a user who has just registered. Their purpose is to make sure the user *got* that token in their email within a set amount of time. It comes in the form of a link, so when the user navigates to that webpage, the app compares that token with the current user's information. For example, the link would be something like `https://www.example.com/auth/confirm/<token_id>`.

![Person with a rare token used to validate people's bank accounts in the 1700's, or something.](https://images.unsplash.com/photo-1533988902751-0fad628013cb?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1502&q=80)

The wrong way to generate tokens is to simply use the user's ID as the token. Once the app gets that link, it knows the user with that ID confirmed their account, right? Ideally, yes, but in practice you can't guarantee that. There are all sorts of bad actors and even those dang kids that never get off your lawn! People like that could exploit this bad design to confirm all sorts of arbitrary accounts, and all they have to do is punch in some lottery numbers.

The right way to generate tokens is to take humans completely out of the picture. Only the app should need to worry about tokens and who's validated their account or not, yes? While humans are clever, computers *can* outsmart them. At least, this is true of token generation. The way this is done is to give only the app the ability to generate *valid* tokens, which enlists the help of your friend, *cryptography*.

Remember back when you made forms and you needed a secret key for Flask-WTF to do cryptographic stuff? It is to protect the user session so that user information is safe. The user session cookies contain a crytpo signature, and if any of the content of the user session is modified, the signature becomes invalid and Flask discards the session to make a new one. A similar method is used for confirmation tokens using the `itdangerous` package, and the same package is used to generate crypto signatures for user sessions. Let's see just how *anti-dangerous* this package really is.

### Generating Tokens With The itsdangerous Package

What's more fun than messing around with cryptography in a Flask shell session? Well, maybe tire swings, but nothing *else* comes close.

![The most fun you'll ever have](https://images.unsplash.com/photo-1566890068693-158bd749501f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1500&q=80)

Go ahead and pull up a Flask shell session and follow along. What you'll do is generate a signed token. This token will look to a human like a bunch of cryptographic magic, or perhaps complete nonsense. However, it will keep a user ID "hidden" inside, which can only be unhidden if certain conditions are met. Go ahead, try it out:

```python
(env) $ flask shell
>>> from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
>>> s = Serializer(app.config['SECRET_KEY'], expires_in=3600)
>>> token = s.dumps({'confirm_id': 42})
>>> token
b'eyJhbGciOiJIUzUxMiIsImlhdCI6MTU4OTA2MDcxOSwiZXhwIjoxNTg5MDY0MzE5fQ.ey ...'
>>> data = s.loads(token)
>>> data
{'confirm_id': 42}
```

While this package can come up with some interesting made-up words, like "pawjema" or "TamNuIo", that's not what you're here for. And no, it doesn't *actually* make up words on purpose, though it *is* fun to look for them.

The `itsdangerous` package provides you with lots of options for token generators, but the one picked here is the `TimedJSONWebSignatureSerializer`. JSON Web Signatures (JWSs) are a state-of-the-art way of ensuring that data doesn't change from when the data was *signed*. If it does change, the signature won't match up and is declared invalid data. Your app's secret key is used as the encryption key for signing the confirmation code. The time expiration ensures that the token is validated within a certain time period. The data becomes invalid if it expires like that half-gallon of milk in the back of Uncle Steve's refrigerator.

The token, or the cryptographic gobbledygook that hides the confirmation code, gets generated using the `dumps()` method of the serializer. Then, to get the data back, you provide the special token to the `loads()` method of the serializer, which *decodes* the token. If the token is invalid or the time expiration has passed, the `loads()` method raises an exception.

### Update The User Model

The next step is to prep your `User` model for holding a confirmation status. That is, you'll add a new column called `confirmed` that's a simple boolean value. You'll be able to check this later for each user to make sure they can access certain parts of the web app. You'll also want to implement the functionality to generate their special token based on their user ID, and then confirm that same user later with the token that was generated:

```python
from flask import current_app
from itsdangerous import TimedJSONWebSignatureSerializer as Serializer

class User(UserMixin, db.Model):
    # ...
    confirmed = db.Column(db.Boolean, default=False)

    # ...

    def generate_confirmation_token(self, expiration_sec=3600):
        s = Serializer(current_app.secret_key, expiration_sec)
        return s.dumps({'confirm_id': self.id}).decode('utf-8')

    def confirm(self, token):
        s = Serializer(current_app.secret_key)
        try:
            data = s.loads(token.encode('utf-8'))
        except:
            return False
        if data.get('confirm_id') != self.id:
            return False
        self.confirmed = True
        db.session.add(self)
        return True
```

The `generate_confirmation_token()` does just as you did in a minute ago and generates a token, but the data it's signing is *this* user's ID. An optional `expiration_sec` argument is provided to control the time expiration, which is by default one hour.

Next is the `confirm()` method, which takes a token and checks whether or not it is valid for that user. It will check

1. that the token itself is valid,
2. that the token hasn't expired, and
3. that the data hidden within matches the user's ID

If any of those are false, the method returns `False`. But if all is fine and dandy, the `User` is thereby confirmed and updated within the database. However, the database session is *not yet committed*. That's because you need to make sure the confirmed user is currently logged in. This is a security measure, as you wouldn't want to confirm a user who can't remember their password, and therefore, can't log in.

### Unit Tests

<div class="alert alert-info" role="alert"><b>Optional Task: </b>Write a unit test that tests whether a confirmation token can be generated and that the user in question can be confirmed successfully</li>
</div>

___

*Fantastic*. You've gotten through generating tokens! This is an important step to ensure your app is as secure as possible. In the next lesson, your users will need to confirm their accounts to continue with using your web app. It's a standard practice in web apps, and for good reason: security for both you and your users.

But hang on, right now they don't actually *need* to confirm their accounts yet... It's time to fix that.
